#!/usr/bin/env python3
"""
============================================================================
FLUX MONISM 3D VISUALIZER
Generate 3D models of particle topologies for Blender rendering
============================================================================

Creates:
  1. .obj mesh files for each particle topology
  2. Interactive HTML visualizations with Plotly
  3. Blender Python script for automated rendering

Usage: 
  python3 flux_monism_3d.py
  
Output:
  - output/models/*.obj          (3D mesh files)
  - output/previews/*.html       (Interactive browser previews)
  - output/render_in_blender.py  (Blender automation script)
"""

import numpy as np
import os
import sys

# Universal constants
PI = np.pi

# Particle topology database
particles = [
    # name, p, q, spin, charge, type, color_hex
    ("Electron",    2, 1, 0.5, -1, "lepton", "#3498db"),  # Blue
    ("Positron",    1, 2, 0.5, +1, "lepton", "#e74c3c"),  # Red
    ("Muon",        4, 1, 0.5, -1, "lepton", "#9b59b6"),  # Purple
    ("Tau",         6, 1, 0.5, -1, "lepton", "#8e44ad"),  # Dark purple
    ("Proton",      3, 2, 0.5, +1, "hadron", "#e67e22"),  # Orange
    ("Neutron",     3, 4, 0.5,  0, "hadron", "#95a5a6"),  # Gray
    ("Lambda",      3, 5, 0.5,  0, "hadron", "#16a085"),  # Teal
    ("Sigma",       4, 3, 0.5,  0, "hadron", "#27ae60"),  # Green
    ("Delta",       5, 2, 1.5, +2, "hadron", "#f39c12"),  # Gold
    ("Omega",       5, 6, 1.5, -1, "hadron", "#2980b9"),  # Blue
    ("Photon",      1, 0, 1.0,  0, "boson",  "#f1c40f"),  # Yellow
]


def generate_torus_knot_mesh(p, q, R=1.0, a=0.3, N=1000, tube_segments=20, tube_radius=0.08):
    """
    Generate a 3D mesh for a (p,q) torus knot with tubular thickness.
    
    Args:
        p, q: Knot parameters
        R: Major radius
        a: Minor radius  
        N: Points along the knot curve
        tube_segments: Circular segments for tube cross-section
        tube_radius: Thickness of the tube
        
    Returns:
        vertices: List of (x, y, z) coordinates
        faces: List of triangle indices
    """
    if p == 1 and q == 0:  # Photon - simple circle
        t = np.linspace(0, 2*PI, N)
        curve = np.column_stack([R * np.cos(t), R * np.sin(t), np.zeros(N)])
    else:
        # Standard torus knot parametric curve
        t = np.linspace(0, 2*PI, N, endpoint=False)
        x = (R + a * np.cos(q * t)) * np.cos(p * t)
        y = (R + a * np.cos(q * t)) * np.sin(p * t)
        z = a * np.sin(q * t)
        curve = np.column_stack([x, y, z])
    
    # Compute tangent vectors (approximation via finite differences)
    tangents = np.roll(curve, -1, axis=0) - curve
    tangents = tangents / (np.linalg.norm(tangents, axis=1, keepdims=True) + 1e-8)
    
    # Compute normal vectors (perpendicular to tangent)
    up = np.array([0, 0, 1])
    normals = np.cross(tangents, up)
    normals = normals / (np.linalg.norm(normals, axis=1, keepdims=True) + 1e-8)
    
    # Compute binormals
    binormals = np.cross(tangents, normals)
    binormals = binormals / (np.linalg.norm(binormals, axis=1, keepdims=True) + 1e-8)
    
    # Generate tube mesh
    vertices = []
    faces = []
    
    theta = np.linspace(0, 2*PI, tube_segments, endpoint=False)
    
    for i in range(N):
        center = curve[i]
        normal = normals[i]
        binormal = binormals[i]
        
        # Create circular cross-section
        for j in range(tube_segments):
            offset = tube_radius * (np.cos(theta[j]) * normal + np.sin(theta[j]) * binormal)
            vertex = center + offset
            vertices.append(vertex)
    
    # Create faces (triangles connecting tube segments)
    for i in range(N):
        for j in range(tube_segments):
            # Current ring
            v1 = i * tube_segments + j
            v2 = i * tube_segments + (j + 1) % tube_segments
            
            # Next ring (wrap around)
            v3 = ((i + 1) % N) * tube_segments + j
            v4 = ((i + 1) % N) * tube_segments + (j + 1) % tube_segments
            
            # Two triangles per quad
            faces.append([v1, v2, v4])
            faces.append([v1, v4, v3])
    
    return np.array(vertices), np.array(faces)


def export_to_obj(vertices, faces, filename):
    """Export mesh to Wavefront OBJ format"""
    with open(filename, 'w') as f:
        f.write(f"# Flux Monism Particle Topology\n")
        f.write(f"# Generated by flux_monism_3d.py\n\n")
        
        # Write vertices
        for v in vertices:
            f.write(f"v {v[0]:.6f} {v[1]:.6f} {v[2]:.6f}\n")
        
        f.write("\n")
        
        # Write faces (OBJ uses 1-based indexing)
        for face in faces:
            f.write(f"f {face[0]+1} {face[1]+1} {face[2]+1}\n")


def generate_plotly_html(vertices, faces, name, p, q, color, filename):
    """Generate interactive HTML preview using Plotly"""
    try:
        import plotly.graph_objects as go
    except ImportError:
        print("Warning: plotly not installed. Skipping HTML preview generation.")
        print("Install with: pip install plotly")
        return
    
    # Create mesh3d plot
    fig = go.Figure(data=[
        go.Mesh3d(
            x=vertices[:, 0],
            y=vertices[:, 1],
            z=vertices[:, 2],
            i=faces[:, 0],
            j=faces[:, 1],
            k=faces[:, 2],
            color=color,
            opacity=0.9,
            name=name
        )
    ])
    
    fig.update_layout(
        title=f"{name} — T({p},{q}) Torus Knot<br>Flux Monism Particle Topology",
        scene=dict(
            xaxis=dict(title="X", backgroundcolor="rgb(230, 230,230)", gridcolor="white"),
            yaxis=dict(title="Y", backgroundcolor="rgb(230, 230,230)", gridcolor="white"),
            zaxis=dict(title="Z", backgroundcolor="rgb(230, 230,230)", gridcolor="white"),
            aspectmode='data'
        ),
        width=900,
        height=700,
    )
    
    fig.write_html(filename)


def generate_blender_script(particle_list, output_dir):
    """Generate Blender Python script for automated rendering"""
    script = '''#!/usr/bin/env python3
"""
Blender Python Script: Render Flux Monism Particle Topologies
Generated by flux_monism_3d.py

Usage in Blender:
  1. Open Blender
  2. Go to Scripting tab
  3. Open this file
  4. Click "Run Script"
  
Or from command line:
  blender --background --python render_in_blender.py
"""

import bpy
import os
from mathutils import Vector

# Configuration
OUTPUT_DIR = "output/renders"
MODEL_DIR = "output/models"
IMAGE_SIZE = (1920, 1080)
SAMPLES = 128

# Particle data
PARTICLES = [
'''
    
    for name, p, q, spin, charge, ptype, color in particle_list:
        script += f'    ("{name}", {p}, {q}, "{color}"),\n'
    
    script += ''']

def setup_scene():
    """Clear default scene and setup rendering"""
    # Delete default objects
    bpy.ops.object.select_all(action='SELECT')
    bpy.ops.object.delete()
    
    # Setup renderer
    bpy.context.scene.render.engine = 'CYCLES'
    bpy.context.scene.cycles.samples = SAMPLES
    bpy.context.scene.render.resolution_x = IMAGE_SIZE[0]
    bpy.context.scene.render.resolution_y = IMAGE_SIZE[1]
    
    # Add camera
    bpy.ops.object.camera_add(location=(5, -5, 3))
    camera = bpy.context.object
    camera.rotation_euler = (1.1, 0, 0.785)
    bpy.context.scene.camera = camera
    
    # Add lighting
    bpy.ops.object.light_add(type='SUN', location=(5, 5, 10))
    sun = bpy.context.object
    sun.data.energy = 2.0
    
    bpy.ops.object.light_add(type='AREA', location=(-5, -5, 5))
    area = bpy.context.object
    area.data.energy = 500
    area.data.size = 5

def hex_to_rgb(hex_color):
    """Convert hex color to RGB tuple"""
    hex_color = hex_color.lstrip('#')
    return tuple(int(hex_color[i:i+2], 16) / 255.0 for i in (0, 2, 4))

def import_and_render(name, p, q, color_hex):
    """Import OBJ and render particle"""
    print(f"\\nRendering {name} T({p},{q})...")
    
    # Clear scene objects (except camera and lights)
    for obj in bpy.data.objects:
        if obj.type == 'MESH':
            bpy.data.objects.remove(obj, do_unlink=True)
    
    # Import OBJ
    obj_file = os.path.join(MODEL_DIR, f"{name.lower()}_T{p}_{q}.obj")
    if not os.path.exists(obj_file):
        print(f"Warning: {obj_file} not found, skipping...")
        return
    
    bpy.ops.import_scene.obj(filepath=obj_file)
    obj = bpy.context.selected_objects[0]
    
    # Create material
    mat = bpy.data.materials.new(name=f"{name}_Material")
    mat.use_nodes = True
    nodes = mat.node_tree.nodes
    
    # Clear default nodes
    nodes.clear()
    
    # Add shader nodes
    output = nodes.new('ShaderNodeOutputMaterial')
    bsdf = nodes.new('ShaderNodeBsdfPrincipled')
    
    # Set color
    rgb = hex_to_rgb(color_hex)
    bsdf.inputs['Base Color'].default_value = (*rgb, 1.0)
    bsdf.inputs['Metallic'].default_value = 0.3
    bsdf.inputs['Roughness'].default_value = 0.4
    
    # Connect nodes
    mat.node_tree.links.new(bsdf.outputs['BSDF'], output.inputs['Surface'])
    
    # Assign material
    if obj.data.materials:
        obj.data.materials[0] = mat
    else:
        obj.data.materials.append(mat)
    
    # Render
    os.makedirs(OUTPUT_DIR, exist_ok=True)
    output_file = os.path.join(OUTPUT_DIR, f"{name.lower()}_T{p}_{q}.png")
    bpy.context.scene.render.filepath = output_file
    bpy.ops.render.render(write_still=True)
    
    print(f"Saved: {output_file}")

def main():
    """Main rendering loop"""
    print("=" * 70)
    print("FLUX MONISM - Blender Particle Topology Renderer")
    print("=" * 70)
    
    setup_scene()
    
    for name, p, q, color in PARTICLES:
        import_and_render(name, p, q, color)
    
    print("\\n" + "=" * 70)
    print("Rendering complete! Check output/renders/ directory")
    print("=" * 70)

if __name__ == "__main__":
    main()
'''
    
    output_file = os.path.join(output_dir, "render_in_blender.py")
    with open(output_file, 'w') as f:
        f.write(script)
    
    os.chmod(output_file, 0o755)
    print(f"Created Blender script: {output_file}")


def main():
    """Main 3D generation pipeline"""
    print("=" * 80)
    print(" " * 20 + "FLUX MONISM 3D TOPOLOGY GENERATOR")
    print("=" * 80)
    print()
    
    # Create output directories
    output_dir = "output"
    models_dir = os.path.join(output_dir, "models")
    previews_dir = os.path.join(output_dir, "previews")
    
    for directory in [output_dir, models_dir, previews_dir]:
        os.makedirs(directory, exist_ok=True)
    
    # Generate meshes for each particle
    for name, p, q, spin, charge, ptype, color in particles:
        print(f"Generating {name} T({p},{q})...")
        
        # Generate 3D mesh
        vertices, faces = generate_torus_knot_mesh(p, q, N=1000, tube_segments=20)
        
        # Export to OBJ
        obj_filename = os.path.join(models_dir, f"{name.lower()}_T{p}_{q}.obj")
        export_to_obj(vertices, faces, obj_filename)
        print(f"  ✓ Exported: {obj_filename}")
        
        # Generate HTML preview
        html_filename = os.path.join(previews_dir, f"{name.lower()}_T{p}_{q}.html")
        generate_plotly_html(vertices, faces, name, p, q, color, html_filename)
        if os.path.exists(html_filename):
            print(f"  ✓ Preview: {html_filename}")
    
    print()
    print("=" * 80)
    
    # Generate Blender automation script
    generate_blender_script(particles, output_dir)
    
    print()
    print("GENERATION COMPLETE!")
    print("-" * 80)
    print(f"OBJ models:       {models_dir}/")
    print(f"HTML previews:    {previews_dir}/")
    print(f"Blender script:   {output_dir}/render_in_blender.py")
    print()
    print("Next steps:")
    print("  1. Open any .html file in a browser to preview knots interactively")
    print("  2. Import .obj files into Blender manually, OR")
    print("  3. Open Blender and run output/render_in_blender.py to auto-render all")
    print("=" * 80)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n\nGeneration interrupted by user.")
        sys.exit(0)
    except Exception as e:
        print(f"\nERROR: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
